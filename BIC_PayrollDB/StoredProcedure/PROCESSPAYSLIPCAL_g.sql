DROP PROCEDURE [dbo].[PROCESSPAYSLIPCAL_g]
GO
CREATE PROCEDURE [dbo].[PROCESSPAYSLIPCAL_g]
(
 @pXMLFILE XML 
)
AS
    BEGIN 
	 
      DECLARE @pEMPID INT ,   
	  @pCOMPID INT, 
	  @pUSERID INT,
	  @pPERIODID INT,
	  @pPERIODTRANS INT ,
	  @pTotGrossIncome Decimal(21,6),
	  @pTotDeduction Decimal(21,6), 
	  @pBASICAMOUNT Decimal(21,6),
	  @pHOURAMOUNT Decimal(21,6),
	  @pDAYAMOUNT Decimal(21,6) ,
	  @pWEEKAMOUNT Decimal(21,6) 
     ------------------------------------------------------------------------------------------
	 DECLARE @verrorId INT 
     DECLARE @vspName VARCHAR(100) 
     SET @vspName = 'PROCESSPAYSLIP_g'
     
     SELECT @pEMPID = N.C.value('@EMPID[1]', 'INT'), 
			@pCOMPID = N.C.value('@COMPID[1]', 'INT'), 
			@pUSERID = N.C.value('@USERID[1]', 'INT') 
     FROM   @pXMLFILE.nodes('//XMLFILE/SPXML/SPDETAILS') N ( C )
    
     EXEC DBLOG_c @pXMLFILE = @pXMLFILE, @pSPNAME = @vSPNAME
     ------------------------------------------------------------------------------------------
        
		BEGIN TRY  

			SELECT @pPERIODID=MID,@pPERIODTRANS=TID FROM dbo.FREQUENCYPERIOD M
			INNER JOIN dbo.FREQUENCYPERIODTRANS T ON T.RMID=M.MID WHERE COMPID=@pCOMPID AND M.ISACTIVE=1 AND M.ISCLOSED=0 AND T.ISCURRENT=1 AND T.ISCLOSED=0
			
			IF OBJECT_ID(N'tempdb..#EmpCalDetails') IS NOT NULL
			BEGIN
			DROP TABLE #EmpCalDetails
			END 
			  
			SELECT  
			E.EMPCODE, 
			P.MID AS MAPPINGID,
			P.HEADID,
			P.EMPID,
			P.CALSEQUENCE,
			P.AMOUNT AS MAPAMOUNT,
			H.HEADCODE, 
			H.TRANSACTIONTYPE,
			S.STATUSCODE TRANSACTIONTYPEDESC,
			H.IsCalculation,
			ISNULL(H.ISAFFECTNATIONALPAY,0)AS ISAFFECTNATIONALPAY,
			ISNULL(H.ISAFFECTPAYSLIP,0)AS ISAFFECTPAYSLIP, 
			ISNULL(H.TYPEOFINPUTID,0)AS TYPEOFINPUTID,
			ISNULL(S1.STATUSCODE,'') AS TYPEOFINPUTDESC,
			ISNULL(H.RATEID,0)AS RATEID,
			ISNULL(R.RATECODE,'') +' '+ISNULL(R.DESCRIPTION,'') AS RATEDESC,
			ISNULL(R.RATE,0)AS RATEMASTER,
			@pPERIODID AS PERIODID,
			@pPERIODTRANS AS PERIODTRANS,
			ISNULL(M.PROCESSID,0)AS PROCESSID,
			CAST(ISNULL(M.QTY,0)AS DECIMAL(21,2))AS QTY, 
			CAST(ISNULL(M.RATE,0)AS DECIMAL(21,2))AS RATE, 
			CAST(ISNULL(M.AMOUNT,CASE WHEN H.TYPEOFINPUTID=1 THEN 0 ELSE P.AMOUNT END)AS DECIMAL(21,2))AS AMOUNT,   
			ISNULL(M.ISOVERRIDE,0)AS ISOVERRIDE, 
			ISNULL(M.ISPROCESSED,0)AS ISPROCESSED,
			ISNULL(M.ISCLOSED,'')AS ISCLOSED 
			INTO #EmpCalDetails
			FROM  dbo.EMPLOYEEPAYMAPPING P 
			INNER JOIN dbo.PAYSLIPHEADS H ON P.HEADID=H.HEADID AND P.ISACTIVE=1 AND H.ISACTIVE=1 AND H.COMPID=@pCOMPID
			INNER JOIN dbo.EMPLOYEE E ON P.EMPID=E.EMPID
			INNER JOIN dbo.StatusMaster S ON H.TRANSACTIONTYPE= S.STATUSID AND S.TYPEID=5
			LEFT JOIN dbo.StatusMaster S1 ON H.TYPEOFINPUTID= S1.STATUSID AND S1.TYPEID=7
			LEFT JOIN dbo.RATEMASTER R ON H.RATEID=R.RATEID  
			INNER JOIN dbo.PROCESSPAYSLIP M ON P.HEADID=M.HEADID AND M.EMPID=P.EMPID  AND M.COMPID=@pCOMPID 
			AND M.ISACTIVE=1 AND ISNULL(M.ISPROCESSED,0)=0 AND ISNULL(M.ISCLOSED,0)=0 AND M.ISOVERRIDE=0
			WHERE  P.EMPID=@pEMPID
			ORDER BY P.CALSEQUENCE 

			 
			
			 DECLARE @pHEADID BIGINT,@pMAPPINGID BIGINT,  @vEMPID BIGINT , @pCALSEQUENCE INT, @pMAPAMOUNT DECIMAL(21,6), @pTRANSACTIONTYPE INT, @pIsCalculation BIT,
				@pISAFFECTNATIONALPAY BIT, @pTYPEOFINPUTID INT , @pRATEID INT, @pRATEMASTER DECIMAL(21,6), @vPERIODID INT , @vPERIODTRANS INT ,
				@pPROCESSID BIGINT, @pQTY  DECIMAL(21,6), @pRATE  DECIMAL(21,6), @pAMOUNT  DECIMAL(21,6), @pISOVERRIDE BIT, @pISPROCESSED BIT , @pISCLOSED BIT 
				
				DECLARE empmapping_cursor CURSOR FOR   
				SELECT HEADID,MAPPINGID,EMPID,CALSEQUENCE,MAPAMOUNT,TRANSACTIONTYPE,IsCalculation,ISAFFECTNATIONALPAY,TYPEOFINPUTID,
				RATEID,RATEMASTER,PERIODID,PERIODTRANS,PROCESSID,QTY,RATE,AMOUNT,ISOVERRIDE
				FROM #EmpCalDetails 
				  
				OPEN empmapping_cursor  
				  
				FETCH NEXT FROM empmapping_cursor   
				INTO @pHEADID,@pMAPPINGID,@pEMPID,@pCALSEQUENCE,@pMAPAMOUNT,@pTRANSACTIONTYPE,@pIsCalculation,@pISAFFECTNATIONALPAY,@pTYPEOFINPUTID,
					@pRATEID,@pRATEMASTER,@pPERIODID,@pPERIODTRANS,@pPROCESSID,@pQTY,@pRATE,@pAMOUNT,@pISOVERRIDE	
				  
				WHILE @@FETCH_STATUS = 0  
				BEGIN    

					IF @pHEADID=1
					BEGIN
						SET @pBASICAMOUNT=@pAMOUNT
					END 

					
					IF @pIsCalculation=1
					BEGIN 				

						IF OBJECT_ID(N'tempdb..#TempVariables') IS NOT NULL
						BEGIN
							DROP TABLE #TempVariables
						END
						
						IF OBJECT_ID(N'tempdb..#TempFormula') IS NOT NULL
						BEGIN
							DROP TABLE #TempFormula
						END 
						
						SELECT F.VARIABLE,F.FIELDID,P.AMOUNT 
						INTO #TempVariables
						FROM dbo.FORMULAVRIABLE F
						INNER JOIN dbo.PROCESSPAYSLIP P ON P.HEADID = F.FIELDID  AND P.COMPID = F.COMPID  
						WHERE F.HEADID=@pHEADID
						AND P.COMPID=@pCOMPID
						AND P.EMPID=@pEMPID
						AND P.ISPROCESSED=0
						AND P.ISCLOSED=0
						AND P.ISACTIVE=1

						CREATE TABLE #TempFormula
						(
							CALID BIGINT,
							CONDITION VARCHAR(1000),
							CONDVALUE VARCHAR(1000),
							CALCULATION VARCHAR(1000),
							CALVALUE VARCHAR(1000),
							RESULTVALUE DECIMAL(21,6),
							CONDRESULT BIT,
							ISEXIT BIT
						)

						INSERT INTO #TempFormula
						        ( CALID,CONDITION ,CONDVALUE ,CALCULATION ,CALVALUE ,RESULTVALUE,CONDRESULT ,ISEXIT)
						SELECT CALID,CONDITION,'',CALCULATION,'',0,0,ISEXIT FROM  dbo.FORMULACALCULATION F WHERE HEADID=@pHEADID AND COMPID=@pCOMPID

						DECLARE @vVARIABLE CHAR(2),
						        @vFIELDID BIGINT ,
								@vAMOUNT DECIMAL(21,6),
								@vCALID BIGINT,
								@vCONDITION VARCHAR(1000),
								@vCONDVALUE VARCHAR(1000),
								@vCALCULATION VARCHAR(1000),
								@vCALVALUE VARCHAR(1000),
								@vRESULTVALUE DECIMAL(21,6),
								@vCONDRESULT BIT,
								@vISEXIT BIT,
								@vCount INT

								SET @vCount = 0 
						
						DECLARE FORMULAVRIABLE_cursor CURSOR FOR  
						SELECT VARIABLE,FIELDID,AMOUNT FROM dbo.#TempVariables  
						
						OPEN FORMULAVRIABLE_cursor   
						FETCH NEXT FROM FORMULAVRIABLE_cursor INTO @vVARIABLE,@vFIELDID ,@vAMOUNT
						
						WHILE @@FETCH_STATUS = 0   
						BEGIN
						
							UPDATE #TempFormula
							SET 
							CONDVALUE=CASE WHEN LEN(CONDITION)>0 
							THEN REPLACE(CASE WHEN @vCount = 0 THEN CONDITION ELSE CONDVALUE END,CONVERT(VARCHAR,LTRIM(RTRIM(@vVARIABLE))),CONVERT(VARCHAR(100),@vAMOUNT)) ELSE '' END,
							CALVALUE=CASE WHEN LEN(CALCULATION)>0 
							THEN REPLACE(CASE WHEN @vCount = 0 THEN CALCULATION ELSE CALVALUE END,CONVERT(VARCHAR,LTRIM(RTRIM(@vVARIABLE))),CONVERT(VARCHAR(100),@vAMOUNT)) ELSE '' END 
							
							SET @vCount=@vCount+1			 
						    FETCH NEXT FROM FORMULAVRIABLE_cursor INTO @vVARIABLE,@vFIELDID ,@vAMOUNT   
						END   
						
						CLOSE FORMULAVRIABLE_cursor   
						DEALLOCATE FORMULAVRIABLE_cursor
						

						DECLARE @vFormula DECIMAL(21,6)
						
						DECLARE FORMULACAL_cursor CURSOR FOR  
						SELECT CALID,CONDITION ,CONDVALUE ,CALCULATION ,CALVALUE ,RESULTVALUE ,CONDRESULT,ISEXIT FROM dbo.#TempFormula  
						
						OPEN FORMULACAL_cursor   
						FETCH NEXT FROM FORMULACAL_cursor INTO @vCALID,@vCONDITION ,@vCONDVALUE ,@vCALCULATION ,@vCALVALUE ,@vRESULTVALUE ,@vCONDRESULT,@vISEXIT
						
						WHILE @@FETCH_STATUS = 0   
						BEGIN
							
							DECLARE @vOUT DECIMAL(21,6), @vSQL NVARCHAR(4000);
							SET @vSQL = N'SELECT @vOUT = ' + @vCALVALUE;
							
							EXEC sp_executesql @vSQL, N'@vOUT DECIMAL(21,6) OUTPUT', @vOUT OUTPUT;
							
							DECLARE @vLOGICALOUT BIT, @vLOGICALSQL NVARCHAR(4000);
							SET @vLOGICALSQL = N'SELECT @vLOGICALOUT = CASE WHEN '+@vCONDVALUE+' THEN 1 ELSE 0 END'
							
							EXEC sp_executesql @vLOGICALSQL, N'@vLOGICALOUT BIT OUTPUT', @vLOGICALOUT OUTPUT;
							
							UPDATE #TempFormula
							SET
							RESULTVALUE= @vOUT,
							CONDRESULT=@vLOGICALOUT
							WHERE CALID=@vCALID

							IF (@vLOGICALOUT=1 AND @vISEXIT=1)
							BEGIN
								SET @pAMOUNT=@vOUT
							END 

						    FETCH NEXT FROM FORMULACAL_cursor INTO @vCALID,@vCONDITION ,@vCONDVALUE ,@vCALCULATION ,@vCALVALUE ,@vRESULTVALUE ,@vCONDRESULT,@vISEXIT   
						END   
						
						CLOSE FORMULACAL_cursor   
						DEALLOCATE FORMULACAL_cursor

						UPDATE dbo.PROCESSPAYSLIP
						SET 
						AMOUNT=@pAMOUNT
						WHERE 
						PROCESSID = @pPROCESSID
						
					END   
				    IF	@pTYPEOFINPUTID=1
					BEGIN  

						DECLARE @vRateVal DECIMAL(21,6)
						DECLARE @vBaseFactorId INT 


						SELECT @vRateVal=RATE,@vBaseFactorId=BASEFACTORID FROM  dbo.RATEMASTER WHERE RATEID=@pRATEID
						--Base Factor id 
						--1	Employee National Pay
						--2	Employee Hourly Pay Rate
						--3	Employee Daily Pay Rate
						--4	Employee Weekly Pay Rate
						--5	Employee Monthly Pay Rate
						--6	Employee Termination Leave Pay
						--7	Employee Annual Leave Pay Rate
						--8	Fixed Rate

						IF @vBaseFactorId=1
						BEGIN
							SET @pRATE = @pBASICAMOUNT * @vRateVal
							SET @pAMOUNT = @pQTY * @pRATE 
						END
						ELSE IF @vBaseFactorId=2
						BEGIN 

							SET @pDAYAMOUNT = @pBASICAMOUNT/30 
							SET @pHOURAMOUNT= @pDAYAMOUNT/8 
							SET @pRATE = @pHOURAMOUNT * @vRateVal 
							SET @pAMOUNT = @pQTY * @pRATE 

						END
						ELSE IF @vBaseFactorId=3
						BEGIN 

							SET @pDAYAMOUNT = @pBASICAMOUNT/30 
							SET @pRATE = @pDAYAMOUNT * @vRateVal
							SET @pAMOUNT = @pQTY * @pRATE 

						END
						ELSE IF @vBaseFactorId=4
						BEGIN 

							SET @pWEEKAMOUNT = @pBASICAMOUNT/4 
							SET @pRATE = @pWEEKAMOUNT * @vRateVal
							SET @pAMOUNT = @pQTY * @pRATE 

						END
						ELSE IF @vBaseFactorId=5
						BEGIN 
						 
							SET @pRATE = @pBASICAMOUNT * @vRateVal
							SET @pAMOUNT = @pQTY * @pRATE 

						END 
						ELSE IF @vBaseFactorId=8
						BEGIN 
						 
							SET @pRATE = @vRateVal
							SET @pAMOUNT = @pQTY * @pRATE 

						END 
					END   

					UPDATE dbo.PROCESSPAYSLIP
					SET RATE =  @pRATE,
					AMOUNT=@pAMOUNT
					WHERE 
					PROCESSID = @pPROCESSID


				    FETCH NEXT FROM empmapping_cursor   
				    INTO @pHEADID,@pMAPPINGID,@pEMPID,@pCALSEQUENCE,@pMAPAMOUNT,@pTRANSACTIONTYPE,@pIsCalculation,@pISAFFECTNATIONALPAY,@pTYPEOFINPUTID,
					@pRATEID,@pRATEMASTER,@pPERIODID,@pPERIODTRANS,@pPROCESSID,@pQTY,@pRATE,@pAMOUNT,@pISOVERRIDE
				END   
				CLOSE empmapping_cursor;  
				DEALLOCATE empmapping_cursor;  


		END TRY 
   
		BEGIN CATCH

		SET @vERRORID = 0 - ERROR_NUMBER() 
		
		SELECT  0 - ERROR_NUMBER() AS 'ID' 

		EXECUTE LogError_i @pXMLFILE, @vERRORID OUTPUT; 

		END CATCH; 
    END 
GO
 